/*
  This file (c) Copyright 1998 - 2002 The MITRE Corporation
  
  This file is part of the Galaxy Communicator system. It is licensed
  under the conditions described in the file LICENSE in the root 
  directory of the Galaxy Communicator system.
*/

// $Id: MainServer.java,v 1.40 2002/06/03 22:00:18 wohlever Exp $

/* These Java bindings were originally produced by Intel Corp.,
   which has granted permission to the Communicator program to
   use and modify them. The preceding MITRE copyright refers to
   whatever changes the MITRE Corporation has made to the code. */

package galaxy.server;

import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.Collections;

import galaxy.util.ListenerLocationInfo;
import galaxy.util.HubContactInfo;
import galaxy.util.DiagnosticLogger;
import galaxy.util.Logger;

/**
 * This is the base class for all Galaxy Java server applications.  MainServer
 * is responsible for listening for connections and spawning 
 * <code>Server</code>s to service requests for those connections.  MainServer
 * can also be configured to connect to a specified set of Hubs upon startup 
 * rather than listening for connections. 
 * <P>
 * You may add a <code>MainServerListener</code> to receive events generated by
 * this class.
 * <P>
 * After constructing the main server, make calls to set options, then call 
 * <code>init()</code> to perform one time initialization. Options include the 
 * port number to listen on, the name of the server class for handling 
 * connections, and a list of Hub host/port pairs to which this server will
 * connect (if this latter option is set, the listener port setting for this 
 * server is ignored). After this you may call <code>start()</code> to start 
 * listening for connections or connect this server to the specified Hub(s).
 * <P>
 * In the case where this server is listening for connections, when a new 
 * connection is received, a server is created to handle the connection. The
 * name of the server class may be specified using 
 * <code>setServerClassName</code> before the main server is started.  It 
 * defaults to <code>galaxy.server.Server</code> The name is used to 
 * dynamically load the server class, and instantiate an instance to handle
 * the connection.  This class must be a subclass of <code>Server</code>. 
 * <P>
 * In the case where this server is configured to connect to a Hub or set of 
 * Hubs, the connections are established, and a server is created for each 
 * connection to handle messages from the associated Hub.
 * <P>
 * This class is intended to be very generic.  Subclasses are used to perform 
 * more specfic tasks.
 *
 * @author Chris Genly
 * @see Server
 * @see MainServerListener
 */
public class MainServer implements Runnable, DiagnosticLogger
{
    /**
     * The name of the Server class to construct to handle a new
     * socket connection.
     */
    protected volatile String serverClassName = "galaxy.server.Server";

    /** This server's name. */
    protected String name = "default";

    /**
     * If true, server will only listen on <tt>port</tt>, otherwise it
     * will increase <tt>port</tt> until it finds a suitible one.
     */
    private volatile boolean requirePort = false;

    /** The required listener port, if any. */
    private int requiredPort = -1;

    /**
     * If true, validate message singatures.
     */
    private volatile boolean validate = false;

    /**
     * Flag that indicates if this server main thread is running.
     */
    private volatile boolean isRunning = false;

    /**
     * Collection of <code>Server</code>s started by this server.
     */
    private Map servers = null;

    /** Collection of all out brokers managed by this server. */
    private Map outBrokers = null;

    /**
     * The port used to listen for connections.
     */
    private volatile int port = 1201;

    /**
     * Maximum number of client connections supported by this server's 
     * listener (if not > 0, no limit is set).
     */
    private volatile int maxConnections = 0; 

    /**
     * Number of active connections created by this server. The
     * <code>servers</code> collection is used as the lock for value since
     * the size of the collection is mirrored by numConnections.
     */
    private int numConnections = 0;
    
    /** 
     * Collection of Hub contact info (represented by 
     * galaxy.util.HubContactInfo instances) for Hubs to which this server
     * should establish connections. 
     */
    private List hubContactInfoCollection = null;

    /** 
     * Hub session id used by this server if it is acting as a client. 
     */
    private volatile String sessionId = null;

    /**
     * A list of MainServerListeners to receive notifications about the server
     * status.
     */
    private List listeners;

    /** The thread that runs this server's main loop. */
    private Thread mainThread = null;

    /** The listener thread started by this server. */
    private ListenerThread listenerThread = null;

    /** The client thread started by this server. */
    private ClientThread clientThread = null;

    /** Need a reference to this server when creating various threads. */
    private MainServer mainServer;

    /** Argument parser. */
    protected ServerArgParser argParser;

    /** 
     * If this bit is set in this servers connection flag, the server listens 
     * for connections from Hubs.
     */
    protected static final int GAL_CONNECTION_LISTENER = 1;

    /** 
     * If this bit is set in this servers connection flag, the server listens 
     * for connections from broker clients.
     */
    protected static final int GAL_BROKER_LISTENER = 2;

    /** 
     * If this bit is set in this servers connection flag, the server contacts 
     * Hubs when establishing connections.
     */
    protected static final int GAL_HUB_CLIENT = 4;

    protected static final int GAL_SERVER_TYPE_MASK = 7; 

    /** 
     * This bit mask indicates what type of connections this server listens 
     * for.
     */
    private int serverListenStatus = 0;

    /**
     * Indicates server should keep trying to connect to Hub until
     * successful.
     */
    public static final int GAL_HUB_CLIENT_CONNECT_FAILURE_RETRY = 0;

    /**
     * Indicates server should shutdown if it can not establish initial
     * connection to Hub.
     */
    public static final int  GAL_HUB_CLIENT_CONNECT_FAILURE_SHUTDOWN = 8;

    /**
     * Indicates server should only make one attempt to contact Hub.
     */
    public static final int GAL_HUB_CLIENT_CONNECT_FAILURE_NOOP = 16;
    
    public static final int GAL_HUB_CLIENT_CONNECT_FAILURE_MASK= 24;

    /**
     * Indicates server should try to reconnect to Hub if connection to Hub 
     * is lost.
     */
    public static final int GAL_HUB_CLIENT_DISCONNECT_RETRY = 0;

    /**
     * Indicates server should shutdown if connection to Hub is lost.
     */
    public static final int GAL_HUB_CLIENT_DISCONNECT_SHUTDOWN = 32;

    /**
     * Indicates server should do nothing if connection to Hub is lost.
     */
    public static final int GAL_HUB_CLIENT_DISCONNECT_NOOP = 64;
    
    public static final int GAL_HUB_CLIENT_DISCONNECT_MASK = 96;
    
    /**
     * Default policy when contacting Hubs is:
     * <P>
     * a) When trying to establish connection to Hub, keep trying until 
     * successful.
     * <P>
     * b) When connection to Hub is lost, try to reconnect.
     */
    public static final int DEFAULT_HUB_CONTACT_POLICY = 0;

    /** Current policy for contacting Hubs. */
    private volatile int hubContactPolicy = MainServer.DEFAULT_HUB_CONTACT_POLICY;
    
    // Verbosity values.
    public final static int NIL_VERBOSITY_LEVEL = 0;

    public final static int CONNECTION_VERBOSITY_LEVEL = 1;
    public final static int ERROR_VERBOSITY_LEVEL = 1;
    public final static int FATAL_VERBOSITY_LEVEL = 1;
    
    public final static int WARNING_VERBOSITY_LEVEL = 2;

    public final static int TRAFFIC_SUMMARY_VERBOSITY_LEVEL = 3;

    public final static int TRAFFIC_DETAILS_VERBOSITY_LEVEL = 4;
    public final static int ERROR_DETAILS_VERBOSITY_LEVEL = 4;
    public final static int FATAL_DETAILS_VERBOSITY_LEVEL = 4;
    public final static int INITIALIZATION_DETAILS_VERBOSITY_LEVEL = 4;

    public final static int THREAD_ACTIVITY_VERBOSITY_LEVEL = 5;
    public final static int TRANSPORT_SUMMARY_VERBOSITY_LEVEL = 5;

    public final static int TRANSPORT_DETAILS_VERBOSITY_LEVEL = 6;

    public final static int DEFAULT_VERBOSITY_LEVEL = 3;
    public final static int MIN_VERBOSITY_LEVEL = 0;
    public final static int MAX_VERBOSITY_LEVEL = 6;

    /** 
     * Flag that indicates the current log message verbosity level.
     * Valid values are 0 (no logging) to 6 (all logging on). The default is 3.
     */
    private volatile static int verbosityLevel = MainServer.DEFAULT_VERBOSITY_LEVEL;

    private Logger logger = null;
    private ListenerLocationInfo listenerInfo = null;

    //=========================================================================
    // Constructors
    //=========================================================================

    /**
     * Default constructor. Note that this does not start the server.
     */
    public MainServer() 
    {
	mainServer = this;
	servers = new HashMap();
	outBrokers = Collections.synchronizedMap(new HashMap());
	listeners = new ArrayList();
	logger = Logger.getLogger();
    }

    /**
     * Constructor. Note that this does not start the server.
     *
     * @param name the server's name
     */
    public MainServer(String name) 
    {
	this();
	setName(name);
    }

    /** 
     * Constructor. Note that this does not start the server.
     *
     * @param name the server's name
     * @param port the port to use (ignored if set to -1)
     */
    public MainServer(String name, int port) 
    {
	this();
	setName(name);
	if(port != -1)
	    setPort(port);
    }

    /**
     * This constructor initializes itself based on the command line arguments.
     * Currently, only these command line arguments are handled by the server:
     * <BR>
     * -port
     * <BR>
     * -assert
     * <BR>
     * -maxconns
     * <BR>
     * -contact_hub
     * <BR>
     * -session_id
     * <BR>
     * -server_locations_file
     * <BR>
     * -validate
     * <BR>
     * -verbosity
     * <BR>
     * Note that this constructor does not start the server.
     *
     * @param name the server's name
     * @param args the command line arguments
     */
    public MainServer(String name, String args[])
    {
	this(name, args, (String) null, -1);
    }

    /**
     * This constructor initializes itself based on the command line arguments.
     * Currently, only these command line arguments are handled by the server:
     * <BR>
     * -port
     * <BR>
     * -assert
     * <BR>
     * -maxconns
     * <BR>
     * -contact_hub
     * <BR>
     * -session_id
     * <BR>
     * -server_locations_file
     * <BR>
     * -validate
     * <BR>
     * -verbosity
     * <BR>
     * Note that this constructor does not start the server.
     *
     * @param name the server's name
     * @param args the command line arguments
     * @param port the port to use (ignored if set to -1)
     */
    public MainServer(String name, String args[], int port)
    {
	this(name, args, (String) null, port);
    }

    /**
     * This constructor initializes itself based on the command line arguments.
     * Currently, only these command line arguments are handled by the server:
     * <BR>
     * -port
     * <BR>
     * -assert
     * <BR>
     * -maxconns
     * <BR>
     * -contact_hub
     * <BR>
     * -session_id
     * <BR>
     * -server_locations_file
     * <BR>
     * -validate
     * <BR>
     * -verbosity
     * <BR>
     * Note that this constructor does not start the server.
     *
     * @param name the server's name
     * @param args the command line arguments
     * @param helpText this text is prepended to the message that is displayed
     *                 when the -help command line argument is used
     */
    public MainServer(String name, String args[], String helpText)
    {
	this(name, args, helpText, -1);
    }

    /**
     * This constructor initializes itself based on the command line arguments.
     * Currently, only these command line arguments are handled by the server:
     * <BR>
     * -port
     * <BR>
     * -assert
     * <BR>
     * -maxconns
     * <BR>
     * -contact_hub
     * <BR>
     * -session_id
     * <BR>
     * -server_locations_file
     * <BR>
     * -validate
     * <BR>
     * -verbosity
     * <BR>
     * Note that this constructor does not start the server.
     *
     * @param name the server's name
     * @param args the command line arguments
     * @param helpText this text is prepended to the message that is displayed
     *                 when the -help command line argument is used
     * @param port the port to use (ignored if set to -1)
     */
    public MainServer(String name, String args[], String helpText, int port)
    {
	this(name, port);
	argParser = new ServerArgParser(args, helpText);

	if(argParser.isArg("-verbosity"))
	    MainServer.setVerbosityLevel(argParser.getIntegerArg("-verbosity", MainServer.DEFAULT_VERBOSITY_LEVEL));
	
	if(argParser.isArg("-port")) {
	    this.port = argParser.getIntegerArg("-port", port);
	    setActsAsHubListener(true); 
	}
	
	if(argParser.isArg("-assert"))
	    requirePort = true;
	

	// Check for information in the server locations file (if present).
	// This will override the -port and -contact_hub command line 
	// arguments.
	listenerInfo = argParser.getListenerLocationInfo(name);
	
	if(listenerInfo != null) {
	    if(listenerInfo.isServerListener()) {
		this.port = listenerInfo.getPort();
		
		// Ports specified in the server locations file are required.
		requirePort = true;
		setActsAsHubListener(true);
	    }
	}

	if(argParser.isArg("-maxconns"))
	    setMaxConnections(argParser.getIntegerArg("-maxconns", 1));
	
	setHubContactInfoCollection(argParser.getHubContactInfoCollection());
	if(hubContactInfoCollection != null && hubContactInfoCollection.size() != 0) {
	    setActsAsHubClient(true);
	} else {
	    // Make this server a listener by default if it is not a Hub client
	    setActsAsHubListener(true);
	}
	
	setSessionId(argParser.getStringArg("-session_id", sessionId));
	
	setValidate(argParser.isArg("-validate"));
    }

    //=========================================================================
    // Settor/gettor/tester methods
    //=========================================================================

    public boolean isRunning()
    { return isRunning; }
   

    public void setActsAsHubListener(boolean actsAsHubListener)
    { 
	if(actsAsHubListener) {
	    serverListenStatus = serverListenStatus | MainServer.GAL_CONNECTION_LISTENER; 
	} else {
	    if((serverListenStatus & MainServer.GAL_CONNECTION_LISTENER) != 0)
		serverListenStatus = serverListenStatus ^ MainServer.GAL_CONNECTION_LISTENER; 
	}
    }

    public boolean isHubListener()
    { 
	if((serverListenStatus & MainServer.GAL_CONNECTION_LISTENER) != 0) {
	    return true;
	} else {
	    return false;
	}
    }

    public void setActsAsBrokerListener(boolean actsAsBrokerListener)
    { 
	if(actsAsBrokerListener) {
	    serverListenStatus = serverListenStatus | MainServer.GAL_BROKER_LISTENER; 
	} else {
	    if((serverListenStatus & MainServer.GAL_BROKER_LISTENER) != 0)
		serverListenStatus = serverListenStatus ^ MainServer.GAL_BROKER_LISTENER; 
	}
    }

    public boolean isBrokerListener()
    { 
	if((serverListenStatus & MainServer.GAL_BROKER_LISTENER) != 0) {
	    return true;
	} else {
	    return false;
	}
    }

    public void setActsAsHubClient(boolean actsAsHubClient)
    { 
	if(actsAsHubClient) {
	    serverListenStatus = serverListenStatus | MainServer.GAL_HUB_CLIENT; 
	} else {
	    if((serverListenStatus & MainServer.GAL_HUB_CLIENT) != 0)
		serverListenStatus = serverListenStatus ^ MainServer.GAL_HUB_CLIENT; 
	}
    }

    public boolean isHubClient()
    {
	if((serverListenStatus & MainServer.GAL_HUB_CLIENT) != 0) {
	    return true;
	} else {
	    return false;
	}
    }

    public ServerArgParser getArgParser()
    {
	return argParser;
    }
    
    public void setValidate(boolean validate)
    { this.validate = validate; }

    boolean getValidate()
    { return validate; }
    
 
    public void setSessionId(String sessionId) 
    { this.sessionId = sessionId; }
    
    public String getSessionId() 
    { return sessionId; }

    /**
     * Sets the listener port used by this server. If a port was specified
     * on the command line (via -port or the -server_locations_file
     * arguments) or the "-assert" command line argument was set, this method 
     * does nothing.
     *
     * @param port this server's listener port
     */
    public void setPort(int port)
    { 	
	if(argParser != null && 
	   (argParser.isArg("-port") || argParser.isArg("-assert") ||
	    listenerInfo != null)) {
	    return;
	}
	this.port = port; 
    }

    public void setRequirePort(boolean requirePort)
    {
	this.requirePort = requirePort;
    }

    /** 
     * Returns the the current listener port of this server.
     */
    public int getPort()
    { 
	return port; 
    }
    
    /*
     * @deprecated As of Galaxy Communicator 3.0. Use isRequiredPort.
     *
    public boolean getRequirePort() 
    { return requirePort; }
    */

    public boolean isRequiredPort() 
    { return requirePort; }


    public void setServerClassName(String serverClassName)
    { this.serverClassName = serverClassName; }

    public String getServerClassName()
    { return serverClassName; }


    public void setHubContactInfoCollection(List newHubContactInfoCollection)
    { 
	hubContactInfoCollection = newHubContactInfoCollection;
    }

    List getHubContactInfoCollection()
    { return hubContactInfoCollection; }


    public void setMaxConnections(int maxConnections)
    { this.maxConnections = maxConnections; }

    public int getMaxConnections()
    { return maxConnections; }


    /**
     * Tests if this server can support a new connection. 
     *
     * @return true if the number of active connections is < maxConnections
     *         (or maxConnections is set to 0), false otherwise 
     */
    boolean canSupportNewConnection()
    {
	if(maxConnections > 0) {
	    synchronized(servers) {
		if(numConnections < maxConnections) {
		    ++numConnections;
		    return true;
		} else {
		    return false;
		}
	    }
	}
	return true;
    }
    
    /**
     * Set this server's name.
     *
     * @param name the server's name. A value of <code>null</code> is ignored 
     *             and the current name is retained.
     */
    public void setName(String name)
    { 
	if(name == null)
	    return;

	this.name = name;
    }

    /**
     * Get this server's name.
     *
     * @return the server's name
     */
    public String getName()
    {
	return name;
    }
    
    /**
     * Sets the Hub contact policy (used if this server is a Hub client).
     * If an invalid policy is specified, no change is made. 
     *
     * @param hubContactPolicy the policy. Valid values include
     * MainServer.DEFAULT_HUB_CONTACT_POLICY, and any or'ed
     * combination of one of a)
     * MainServer.GAL_HUB_CLIENT_CONNECT_FAILURE_RETRY,
     * MainServer.GAL_HUB_CLIENT_CONNECT_FAILURE_SHUTDOWN, or
     * MainServer.GAL_HUB_CLIENT_CONNECT_FAILURE_NOOP, and one of b)
     * MainServer.GAL_HUB_CLIENT_DISCONNECT_RETRY,
     * MainServer.GAL_HUB_CLIENT_DISCONNECT_SHUTDOWN, and
     * MainServer.GAL_HUB_CLIENT_DISCONNECT_NOOP.
     */
    public void setHubContactPolicy(int hubContactPolicy)
    {
	if(hubContactPolicy == MainServer.DEFAULT_HUB_CONTACT_POLICY ||
	   (hubContactPolicy & (MainServer.GAL_HUB_CLIENT_CONNECT_FAILURE_RETRY | 
				MainServer.GAL_HUB_CLIENT_CONNECT_FAILURE_SHUTDOWN |
				MainServer.GAL_HUB_CLIENT_CONNECT_FAILURE_NOOP |
				MainServer.GAL_HUB_CLIENT_DISCONNECT_RETRY |
				MainServer.GAL_HUB_CLIENT_DISCONNECT_SHUTDOWN | 
				MainServer.GAL_HUB_CLIENT_DISCONNECT_NOOP)) != 0) {
	    this.hubContactPolicy = hubContactPolicy;
	}
    }

    /**
     * Gets the current policy for contacting Hubs.
     *
     * @return Hub contact policy flag
     */
    public int getHubContactPolicy()
    {
	return hubContactPolicy;
    }

    /**
     * Sets the current logging verbosity level.
     *
     * @param verbosityLevel the verbosity level. At the moment, the only 
     *                       valid values are0 (no logging) and 1 (all logging
     *                       on). If an invalid value is specified, the
     *                       current verbosity level is not changed.
     */
    public static void setVerbosityLevel(int verbosityLevel)
    {
	if(verbosityLevel >= MIN_VERBOSITY_LEVEL && verbosityLevel <= MAX_VERBOSITY_LEVEL)
	    MainServer.verbosityLevel = verbosityLevel;
    }

    /**
     * Returns the current logging verbosity level.
     *
     * @return the verbosity level. At the moment, the only valid values are
     *         0 (no logging) and 1 (all logging on).
     */
    public static int getVerbosityLevel()
    {
	return MainServer.verbosityLevel;
    }

    //=========================================================================
    // Main thread management methods
    //=========================================================================

    /**
     * Adds the specified Hub info to the list of Hubs to contact.
     *
     * @param host name of the Hub's host machine
     * @param port listener port of the Hub
     * @param sessionId session id to use for the connection
     * @param hubContactPolicy Hub contact policy flag (if -1, current
     *                         policy of this MainServer is always used).
     */
    public void contactHub(String host, int port, String sessionId, 
			   int hubContactPolicy)
    {
	if(!startHubClientThread()) {
	    // If this server is not running, create the client thread but 
	    // don't start it. Leave that for the server thread startup to 
	    // handle.
	    clientThread = new ClientThread(mainServer);
	}

	if(hubContactInfoCollection == null)
	    hubContactInfoCollection = new ArrayList();

	hubContactInfoCollection.add(new HubContactInfo(host, port, sessionId,
							hubContactPolicy));
	
	clientThread.contactHub(host, port, sessionId, 
				(hubContactPolicy == -1 ? 
				 getHubContactPolicy() :
				 hubContactPolicy));
    }

    /**
     * Tests if the listener thread started by this server has acquired a port.
     *
     * @return true if the listener has a port, false otherwise (including
     *         when this server does not have a listener thread)
     */
    protected boolean listenerHasPort()
    {
	if(listenerThread != null && 
	   (isHubListener() || isBrokerListener())) {
	    return listenerThread.listenerHasPort(); 
	} 
	return false;
    }

    /**
     * Starts this server's listener thread if it is not already running.
     * The server thread must be running in order for the listener thread to
     * run. There is only on listener thread listening for both Hub and
     * brokers connections, so if the "broker listener" is running, no
     * other thread is started.
     *
     * @return false if the server is not running
     */
    private boolean startHubListenerThread()
    {
	if(!isRunning)
	    return false;
	
	setActsAsHubListener(true);
	if(listenerThread == null) {
	    listenerThread = new ListenerThread(mainServer);
	}

	if(!listenerThread.isRunning()) {
	    logMessage("Attempting to start listener thread.", 
		       MainServer.THREAD_ACTIVITY_VERBOSITY_LEVEL,
		       "MainServer.startHubListenerThread()");
	    listenerThread.start();
	}
	return true;
    }
    
    /**
     * Starts this server's listener thread if it is not already running.
     * The server thread must be running in order for the listener thread to
     * run. There is only on listener thread listening for both Hub and
     * brokers connections, so if the "Hub listener" is running, no
     * other thread is started.
     *
     * @return false if the server is not running
     */
    protected boolean startBrokerListenerThread()
    {
	if(!isRunning)
	    return false;

	setActsAsBrokerListener(true);
	if(listenerThread == null) {
	    listenerThread = new ListenerThread(mainServer);
	}

	if(!listenerThread.isRunning()) {
	    logMessage("Attempting to start listener thread.", 
		       MainServer.THREAD_ACTIVITY_VERBOSITY_LEVEL,
		       "MainServer.startBrokerListenerThread()");
	    listenerThread.start();
	}
	return true;
    }

    /**
     * Starts this server's Hub client thread if it is not already running.
     * The server thread must be running in order for the client thread to
     * run.
     *
     * @return false if the server is not running
     */
    private boolean startHubClientThread()
    {
	if(!isRunning)
	    return false;

	setActsAsHubClient(true);
	if(clientThread == null) {
	    clientThread = new ClientThread(mainServer);	
	}

	if(!clientThread.isRunning()) {
	    logMessage("Attempting to start client thread.", 
		       MainServer.THREAD_ACTIVITY_VERBOSITY_LEVEL,
		       "MainServer.startHubClientThread()");
	    clientThread.start();
	}
	return true;
    }

    /**
     * Call this function to initialize the main server.  It is called after
     * setting various parameters, such as the port number and dialogue file 
     * name. It must be called exactly once.  Upon return, you may call start()
     * and stop().
     */
    public void init() throws Exception {}
 
    /**
     * Starts this server's thread if it is not already running.
     */
    public void start()
    {
	if (!isRunning) {	
	    mainThread = new Thread(mainServer, "MainServerThread");
	    mainThread.start();
	}
    }

    /**
     * This cleanup method is called when this server is preparing to stop.
     * This is called after the "listener" and/or "client" threads have stopped
     * and all <code>Server</code> objects (and their outgoing brokers)
     * created by this server have stopped.
     * Override this method to provide your own customized cleanup routine.
     */
    protected void cleanup()
    {
    }

    /**
     * Causes this server's thread to be stopped. The thread is not
     * actually stopped until this condition is tested in the thread's
     * main loop.
     */
    public void stop()
    {	
	isRunning = false;
    }

    /**
     * This server's main loop. The server starts the listener and/or
     * client thread(s) as needed and then waits to be stopped. Once it is
     * interrupted, it stops the listener and/or client thread, stops all
     * server threads it started, and stops all outgoing brokers that it
     * is managing.
     */
    public void run()
    {
	isRunning = true;
	fireStarted();

	// If this server is not a Hub client and it has a valid listener
	// port, but it has not been marked as being a listener, mark it as
	// such now.
	if(!isHubClient() && port != -1)
	    setActsAsHubListener(true);

	if(isHubListener())
	    startHubListenerThread();
	
	if(isBrokerListener())
	    startBrokerListenerThread();

	if(isHubClient())
	    startHubClientThread();

	if(isHubListener() || isBrokerListener() || isHubClient()) {
	    try {

		while(isRunning) {
		    // Sleep for one second.
		    try{ 
			Thread.sleep(1000);
		    } catch(InterruptedException iex) {
		    }
		}
	
		logMessage("MainServer thread has been interrupted.", 
			   MainServer.THREAD_ACTIVITY_VERBOSITY_LEVEL,
			   "MainServer.run()");

		// Interrupt and join on the listener and/or client threads.
		if(isHubListener() || isBrokerListener()) {
		    listenerThread.stopThread();
		    listenerThread.join();
		    listenerThread = null;
		}
		
		if(isHubClient()) {
		    clientThread.stopThread();
		    clientThread.join();
		    clientThread = null;
		}

		// Stop the servers.
		synchronized(servers) {
		    Collection serverCollection = servers.values();
		    Iterator iterator = serverCollection.iterator();
		    Server server;
		    while(iterator.hasNext()) {
			server = (Server) iterator.next();
			server.stop();
		    }
		}

		// Stop this server's outgoing brokers.
		synchronized(outBrokers) {
		    Collection brokerCollection = outBrokers.values();
		    Iterator iterator = brokerCollection.iterator();
		    DataOutBroker broker;
		    while(iterator.hasNext()) {
			broker = (DataOutBroker) iterator.next();
			broker.stop();
		    }
		}
		
	    } catch(Exception ex) {
		logErrorMessage("Main server caught exception in main thread: " + ex.toString(), ex, "MainServer.run()");
	    }
	}

	fireStopped();
	cleanup();
	logMessage("Main server stopped.", 
		   MainServer.THREAD_ACTIVITY_VERBOSITY_LEVEL,
		   "MainServer.run()");
    }


    //=========================================================================
    // Server registration and initialization methods
    //=========================================================================

    /**
     * Registers a server thread this the main server.
     *
     * @param serverThread the server's thread
     * @param server the server object
     */
    void registerServer(Thread serverThread, Server server) 
    {
	synchronized(servers) {
	    servers.put(serverThread, server);
	}
    }
    
    /**
     * Unregisters a server thread.
     *
     * @param serverThread the thread to unregister
     */
    void unregisterServer(Thread serverThread) 
    {
	synchronized(servers) {
	    Object serverObj = servers.get(serverThread);
	    if(serverObj == null) {
		logErrorMessage("Error in main server while trying to unregister server.", "MainServer.unregisterServer(Thread)");
	    } else {
		servers.remove(serverThread);

		// Decrement the connection count.
		--numConnections;
	    }
	}
    }

    /**
     * Called by the framework after createServer().  The method
     * may be redefined by subclasses to perform specialized
     * server initialization.
     */
    protected void initServer(Server server) throws Exception
    {
    } 


    //=========================================================================
    // Broker management methods.
    //=========================================================================

    /** 
     * Registers an outgoing broker that is managed by this server.
     *
     * @param broker the broker
     */
    protected void registerOutBroker(DataOutBroker broker) 
    {
	logMessage("MainServer registering out broker (callId = " + broker.getCallId() + ").",
		   MainServer.THREAD_ACTIVITY_VERBOSITY_LEVEL,
		   "MainServer.registerOutBroker(DataOutBroker)");
	outBrokers.put(broker.getCallId(), broker);
    }

    /** 
     * Unregisters an outgoing broker is managed by this server.
     *
     * @param broker the broker
     * @return true if the broker was found and unregistered, false if the
     *         broker was not found
     */
    protected boolean unregisterOutBroker(DataOutBroker broker) 
    {
	logMessage("MainServer unregistering out broker (callId = " + broker.getCallId() + ").",
		   MainServer.THREAD_ACTIVITY_VERBOSITY_LEVEL,
		   "MainServer.unregisterOutBroker(DataOutBroker)");
	return(outBrokers.remove(broker.getCallId()) != null);
    }

    /**
     * Finds an outgoing broker managed by this server based on a call ID.
     *
     * @param callId the call ID
     * @return the outgoing broker or null if a match was not found
     */
    DataOutBroker findBroker(String callId)
    {
	return (DataOutBroker) outBrokers.get(callId);
    }
    
    /**
     * Indicates if this server is managing any outgoing brokers.
     *
     * @return true if this server has brokers, false otherwise
     */
    boolean supportsBrokerConnections()
    {
	return (outBrokers.size() > 0);
    }

    //=========================================================================
    // Event-related methods
    //=========================================================================
    
    /**
     * Add a MainServerListener.  Multiple listeners are permitted.
     */
    public void addMainServerListener(MainServerListener listener)
    {
	synchronized(listeners) {
	    listeners.add(listener);
	}
    }

    public void removeMainServerListener(MainServerListener listener)
    {
	synchronized(listeners) {
	    listeners.remove(listener);
	}
    }

    private boolean fireStarted()
    {
	List listenersClone;
	synchronized(listeners) {
	    listenersClone = (List) ((ArrayList)listeners).clone();
	}
	
	if(listenersClone.size() > 0) {
	    Iterator iterator = listenersClone.iterator();
	    MainServerListener listener;
	    while(iterator.hasNext()) {
		listener = (MainServerListener) iterator.next();
		listener.mainServerStarted(this);
	    }
	    return true;
	} else
	    return false;
    }
    
    private boolean fireStopped()
    {
	List listenersClone;
	synchronized(listeners) {
	    listenersClone = (List) ((ArrayList)listeners).clone();
	}
	
	if(listenersClone.size() > 0) {
	    Iterator iterator = listenersClone.iterator();
	    MainServerListener listener;
	    while(iterator.hasNext()) {
		listener = (MainServerListener) iterator.next();
		listener.mainServerStopped(this);
	    }
	    return true;
	} else
	    return false;
    }
    
    private boolean fireErrorMessage(String msg)
    {
	return fireErrorMessage(msg, null);
    }
    
    private boolean fireErrorMessage(String msg, Exception ex)
    {
	List listenersClone;
	synchronized(listeners) {
	    listenersClone = (List) ((ArrayList)listeners).clone();
	}

	if(listenersClone.size() > 0) {
	    Iterator iterator = listenersClone.iterator();
	    MainServerListener listener;
	    while(iterator.hasNext()) {
		listener = (MainServerListener) iterator.next();
		if(ex != null)
		    listener.mainServerErrorMessage(this, msg, ex);
		else
		    listener.mainServerErrorMessage(this, msg);
	    }
	    return true;
	} else
	    return false;
    }
    
    private boolean fireFatalErrorMessage(String msg)
    {
	return fireFatalErrorMessage(msg, null);
    }
    
    private boolean fireFatalErrorMessage(String msg, Exception ex)
    {
	List listenersClone;
	synchronized(listeners) {
	    listenersClone = (List) ((ArrayList)listeners).clone();
	}

	if(listenersClone.size() > 0) {
	    Iterator iterator = listenersClone.iterator();
	    MainServerListener listener;
	    while(iterator.hasNext()) {
		listener = (MainServerListener) iterator.next();
		if(ex != null)
		    listener.mainServerFatalErrorMessage(this, msg, ex);
		else
		    listener.mainServerFatalErrorMessage(this, msg);
	    }
	    return true;
	} else
	    return false;
    }

    private boolean fireWarningMessage(String msg)
    {
	List listenersClone;
	synchronized(listeners) {
	    listenersClone = (List) ((ArrayList)listeners).clone();
	}

	if(listenersClone.size() > 0) {
	    Iterator iterator = listenersClone.iterator();
	    MainServerListener listener;
	    while(iterator.hasNext()) {
		listener = (MainServerListener) iterator.next();
		listener.mainServerWarningMessage(this, msg);
	    }
	    return true;
	} else
	    return false;
    }
    
    private boolean fireMessage(String msg)
    {
	List listenersClone;
	synchronized(listeners) {
	    listenersClone = (List) ((ArrayList)listeners).clone();
	}

	if(listenersClone.size() > 0) {
	    Iterator iterator = listenersClone.iterator();
	    MainServerListener listener;
	    while(iterator.hasNext()) {
		listener = (MainServerListener) iterator.next();
		listener.mainServerMessage(this, msg);
	    }
	    return true;
	} else
	    return false;
    }
    
    // ServerCreationThread uses this method, too, so it is not private.
    boolean fireNewServer(Server server)
    {
	List listenersClone;
	synchronized(listeners) {
	    listenersClone = (List) ((ArrayList)listeners).clone();
	}

	if(listenersClone.size() > 0) {
	    Iterator iterator = listenersClone.iterator();
	    MainServerListener listener;
	    while(iterator.hasNext()) {
		listener = (MainServerListener) iterator.next();
		listener.mainServerNewServer(this, server);
	    }
	    return true;
	} else
	    return false;
    }
    
    
    //=========================================================================
    // Logging and error reporting methods
    //=========================================================================
    
    /** @deprecated As of Galaxy Communicator 4.0. Use logMessage(String, int). */
    protected void log(String msg)
    {
	logMessage(msg, MainServer.ERROR_VERBOSITY_LEVEL);
    }
    
    /** @deprecated As of Galaxy Communicator 4.0. Use logErrorMessage(String). */
    protected void error(String msg)
    {
	error(msg, null);
    }
    
    /** @deprecated As of Galaxy Communicator 4.0. Use logErrorMessage(String, Exception). */
    protected  void error(String msg, Exception ex)
    {
	if((MainServer.getVerbosityLevel() > MainServer.NIL_VERBOSITY_LEVEL) &&
	   !fireErrorMessage(msg, ex)) {
	    System.out.println("*** " + msg);
	    if(ex != null)
		ex.printStackTrace();
	}
    }
    
    /** @deprecated As of Galaxy Communicator 4.0. Use logFatalMessage(String). */
    protected void fatal(String msg)
    {
        fatal(msg, null);
    }
    
    /** @deprecated As of Galaxy Communicator 4.0. Use logFatalMessage(String, Exception). */
    protected void fatal(String msg, Exception ex)
    {
	if(!fireFatalErrorMessage(msg, ex)) {
	    if(MainServer.getVerbosityLevel() > MainServer.NIL_VERBOSITY_LEVEL) {
		System.out.println("!!! " + msg);
		if(ex != null)
		    ex.printStackTrace();
	    }
	    System.exit(1);
	}
	stop();
    } 

    public void logMessage(String msg, int level)
    {
	logMessage(msg, level, null);
    } 

    public void logMessage(String msg, int level, String location)
    {
	if(MainServer.getVerbosityLevel() >= level) {
	    String newMsg = msg;
	    if(location != null && MainServer.getVerbosityLevel() >= 4)
		if(msg.startsWith("\n"))
		    newMsg = new String("\n" + location + ": " + msg.substring(1));
		else
		    newMsg = new String("\n" + location + ": " + msg);
	    if(!fireMessage(newMsg))
		logger.logMessage(msg, level, location);
	}
    } 

    public void logMessage(String msg)
    {
	if(!fireMessage(msg))
	    logger.logMessage(msg);
    }
    
    public void logErrorMessage(String msg)
    {
	logErrorMessage(msg, null, null);
    }
    
    public void logErrorMessage(String msg, Exception ex)
    {
	logErrorMessage(msg, ex, null);
    }

    public void logErrorMessage(String msg, String location)
    {
	logErrorMessage(msg, null, location);
    }
    
    public void logErrorMessage(String msg, Exception ex, String location)
    {
	if(MainServer.getVerbosityLevel() >= MainServer.ERROR_VERBOSITY_LEVEL) {
	    String newMsg = msg;
	    if(location != null && MainServer.getVerbosityLevel() >= 4)
		if(msg.startsWith("\n"))
		    newMsg = new String("\n" + location + ": " + msg.substring(1));
		else
		    newMsg = new String("\n" + location + ": " + msg);
	    if(!fireErrorMessage(newMsg, ex))  
		logger.logErrorMessage(msg, ex, location);
	}
    }
    
    public void logFatalMessage(String msg)
    {
	logFatalMessage(msg, null, null);
    }
    
    public void logFatalMessage(String msg, Exception ex)
    {
	logFatalMessage(msg, ex, null);
    } 

    public void logFatalMessage(String msg, String location)
    {
	logFatalMessage(msg, null, location);
    }
    
    public void logFatalMessage(String msg, Exception ex, String location)
    {
	if(MainServer.getVerbosityLevel() >= MainServer.ERROR_VERBOSITY_LEVEL) {
	    String newMsg = msg;
	    if(location != null && MainServer.getVerbosityLevel() >= 4)
		if(msg.startsWith("\n"))
		    newMsg = new String("\n" + location + ": " + msg.substring(1));
		else
		    newMsg = new String("\n" + location + ": " + msg);
	    if(!fireFatalErrorMessage(newMsg, ex))
		logger.logFatalMessage(msg, ex, location);
	}
    }

    public void logWarningMessage(String msg)
    {
	logWarningMessage(msg, null);
    }

    public void logWarningMessage(String msg, String location)
    {
	if(MainServer.getVerbosityLevel() >= MainServer.WARNING_VERBOSITY_LEVEL) {
	    String newMsg = msg;
	    if(location != null && MainServer.getVerbosityLevel() >= 4)
		if(msg.startsWith("\n"))
		    newMsg = new String("\n" + location + ": " + msg.substring(1));
		else
		    newMsg = new String("\n" + location + ": " + msg);
	    if(!fireWarningMessage(newMsg))
		logger.logWarningMessage(msg, location);
	}
    }
}

